import datetime
import statistics
from typing import List, Dict, Tuple

class MonitoramentoGlicemia:
    def __init__(self):
        self.registros = []
        self.metas = {
            'jejum_min': 70,
            'jejum_max': 130,
            'pos_refeicao_min': 70,
            'pos_refeicao_max': 180,
            'meta_hemoglobina': 7.0
        }

    def menu_monitoramento(self):
        while True:
            print("\nğŸ©¸ MONITORAMENTO DE GLICEMIA")
            print("1. Novo registro")
            print("2. Ver histÃ³rico")
            print("3. EstatÃ­sticas e relatÃ³rios")
            print("4. Definir metas")
            print("5. Voltar")
            
            opcao = input("Escolha: ")
            
            if opcao == '1':
                self.novo_registro()
            elif opcao == '2':
                self.ver_historico()
            elif opcao == '3':
                self.gerar_relatorios()
            elif opcao == '4':
                self.definir_metas()
            elif opcao == '5':
                break
            else:
                print("OpÃ§Ã£o invÃ¡lida!")

    def novo_registro(self):
        print("\nğŸ“ NOVO REGISTRO DE GLICEMIA")
        
        try:
            valor = int(input("Valor da glicemia (mg/dL): "))
            data_str = input("Data (DD/MM/AAAA) ou Enter para hoje: ")
            hora_str = input("Hora (HH:MM) ou Enter para agora: ")
            
            if not data_str:
                data_hora = datetime.datetime.now()
            else:
                if not hora_str:
                    hora_str = "00:00"
                data_hora = datetime.datetime.strptime(f"{data_str} {hora_str}", "%d/%m/%Y %H:%M")
            
            print("\nTipo de mediÃ§Ã£o:")
            print("1. Jejum")
            print("2. PÃ³s-refeiÃ§Ã£o (2h apÃ³s)")
            print("3. PrÃ©-refeiÃ§Ã£o")
            print("4. Antes de dormir")
            print("5. AleatÃ³ria")
            
            tipo_opcao = input("Escolha o tipo (1-5): ")
            tipos = {
                '1': 'Jejum',
                '2': 'PÃ³s-refeiÃ§Ã£o',
                '3': 'PrÃ©-refeiÃ§Ã£o',
                '4': 'Antes de dormir',
                '5': 'AleatÃ³ria'
            }
            tipo = tipos.get(tipo_opcao, 'AleatÃ³ria')
            
            refeicao = input("RefeiÃ§Ã£o associada (cafÃ©, almoÃ§o, jantar, lanche): ") if tipo == 'PÃ³s-refeiÃ§Ã£o' else ""
            observacoes = input("ObservaÃ§Ãµes (sintomas, atividades, etc.): ")
            
            registro = {
                'data_hora': data_hora,
                'valor': valor,
                'tipo': tipo,
                'refeicao': refeicao,
                'observacoes': observacoes,
                'status': self.avaliar_glicemia(valor, tipo)
            }
            
            self.registros.append(registro)
            self.registros.sort(key=lambda x: x['data_hora'])
            
            print(f"\nâœ… Registro salvo! Status: {registro['status']}")
            
        except ValueError:
            print("âŒ Erro nos dados inseridos!")

    def avaliar_glicemia(self, valor: int, tipo: str) -> str:
        if tipo == 'Jejum':
            if valor < self.metas['jejum_min']:
                return "HIPOGLICEMIA âš ï¸"
            elif valor > self.metas['jejum_max']:
                return "ACIMA DA META ğŸ”´"
            else:
                return "DENTRO DA META âœ…"
        
        elif tipo == 'PÃ³s-refeiÃ§Ã£o':
            if valor < self.metas['pos_refeicao_min']:
                return "HIPOGLICEMIA âš ï¸"
            elif valor > self.metas['pos_refeicao_max']:
                return "ACIMA DA META ğŸ”´"
            else:
                return "DENTRO DA META âœ…"
        
        else:
            if valor < 70:
                return "HIPOGLICEMIA âš ï¸"
            elif valor > 200:
                return "ELEVADO ğŸ”´"
            elif valor > 140:
                return "MODERADO ğŸŸ¡"
            else:
                return "NORMAL âœ…"

    def ver_historico(self):
        if not self.registros:
            print("Nenhum registro encontrado.")
            return
        
        print(f"\nğŸ“‹ HISTÃ“RICO DE GLICEMIA ({len(self.registros)} registros)")
        print("=" * 80)
        
        for registro in self.registros[-10:]:  # Ãšltimos 10 registros
            data_formatada = registro['data_hora'].strftime("%d/%m/%Y %H:%M")
            print(f"ğŸ“… {data_formatada} | {registro['valor']} mg/dL")
            print(f"   Tipo: {registro['tipo']} | Status: {registro['status']}")
            if registro['refeicao']:
                print(f"   RefeiÃ§Ã£o: {registro['refeicao']}")
            if registro['observacoes']:
                print(f"   Obs: {registro['observacoes']}")
            print("-" * 40)

    def gerar_relatorios(self):
        if not self.registros:
            print("Nenhum dado para anÃ¡lise.")
            return
        
        hoje = datetime.datetime.now().date()
        ultimos_7_dias = [r for r in self.registros 
                         if r['data_hora'].date() >= hoje - datetime.timedelta(days=7)]
        
        if not ultimos_7_dias:
            print("Nenhum registro nos Ãºltimos 7 dias.")
            return
        
        valores = [r['valor'] for r in ultimos_7_dias]
        
        print("\nğŸ“Š RELATÃ“RIO DOS ÃšLTIMOS 7 DIAS")
        print("=" * 50)
        print(f"Total de mediÃ§Ãµes: {len(ultimos_7_dias)}")
        print(f"MÃ©dia de glicemia: {statistics.mean(valores):.1f} mg/dL")
        print(f"Mediana: {statistics.median(valores):.1f} mg/dL")
        print(f"VariaÃ§Ã£o: {min(valores)} - {max(valores)} mg/dL")
        
        # AnÃ¡lise por tipo de mediÃ§Ã£o
        print("\nğŸ“ˆ ANÃLISE POR TIPO:")
        tipos = {}
        for registro in ultimos_7_dias:
            tipo = registro['tipo']
            if tipo not in tipos:
                tipos[tipo] = []
            tipos[tipo].append(registro['valor'])
        
        for tipo, valores_tipo in tipos.items():
            media = statistics.mean(valores_tipo)
            status = self.avaliar_glicemia(int(media), tipo)
            print(f"   {tipo}: {media:.1f} mg/dL - {status}")
        
        # EstatÃ­sticas de controle
        dentro_meta = sum(1 for r in ultimos_7_dias if 'DENTRO' in r['status'])
        percentual_controle = (dentro_meta / len(ultimos_7_dias)) * 100
        
        print(f"\nğŸ¯ CONTROLE GLICÃŠMICO: {percentual_controle:.1f}% dentro da meta")
        
        if percentual_controle > 80:
            print("ğŸŒŸ Excelente controle!")
        elif percentual_controle > 60:
            print("ğŸ’ª Bom controle, continue assim!")
        else:
            print("ğŸ“ AtenÃ§Ã£o: procure ajustar tratamento")

    def definir_metas(self):
        print("\nğŸ¯ DEFINIR METAS GLICÃŠMICAS")
        print(f"Metas atuais: Jejum {self.metas['jejum_min']}-{self.metas['jejum_max']} mg/dL")
        print(f"PÃ³s-refeiÃ§Ã£o: {self.metas['pos_refeicao_min']}-{self.metas['pos_refeicao_max']} mg/dL")
        
        try:
            print("\nNovas metas:")
            self.metas['jejum_min'] = int(input("Glicemia jejum mÃ­nima (mg/dL): "))
            self.metas['jejum_max'] = int(input("Glicemia jejum mÃ¡xima (mg/dL): "))
            self.metas['pos_refeicao_min'] = int(input("Glicemia pÃ³s-refeiÃ§Ã£o mÃ­nima (mg/dL): "))
            self.metas['pos_refeicao_max'] = int(input("Glicemia pÃ³s-refeiÃ§Ã£o mÃ¡xima (mg/dL): "))
            
            print("âœ… Metas atualizadas com sucesso!")
            
        except ValueError:
            print("âŒ Valores invÃ¡lidos!")

    def alertas_importantes(self):
        """Verifica situaÃ§Ãµes que requerem atenÃ§Ã£o"""
        if not self.registros:
            return []
        
        alertas = []
        ultimo_registro = self.registros[-1]
        
        # Verifica hipoglicemia severa
        if ultimo_registro['valor'] < 60:
            alertas.append("ğŸš¨ HIPOGLICEMIA SEVERA - Procure atendimento!")
        
        # Verifica hiperglicemia crÃ­tica
        elif ultimo_registro['valor'] > 300:
            alertas.append("ğŸš¨ GLICEMIA MUITO ALTA - Procure orientaÃ§Ã£o mÃ©dica!")
        
        # Verifica tendÃªncia de hipoglicemia
        ultimos_3 = [r['valor'] for r in self.registros[-3:] if len(self.registros) >= 3]
        if len(ultimos_3) == 3 and all(v < 80 for v in ultimos_3):
            alertas.append("ğŸ“‰ TendÃªncia de hipoglicemia - Ajuste medicamento/alimentaÃ§Ã£o")
        
        return alertas

# Atualizar a classe principal DiabetesApp para incluir o monitoramento
class DiabetesApp:
    def __init__(self):
        self.agendamentos = []
        self.alimentos_db = { ... }  # Manter o cÃ³digo anterior
        self.prato_atual = []
        self.monitoramento = MonitoramentoGlicemia()  # Nova funcionalidade

    def menu_principal(self):
        while True:
            print("\n=== APP DIABETES ===")
            print("1. Agendamentos")
            print("2. Monte seu Prato")
            print("3. Monitoramento de Glicemia")  # Nova opÃ§Ã£o
            print("4. Sair")
            
            # Verificar alertas importantes
            alertas = self.monitoramento.alertas_importantes()
            if alertas:
                print("\nâš ï¸  ALERTAS:")
                for alerta in alertas:
                    print(f"   {alerta}")
            
            opcao = input("Escolha uma opÃ§Ã£o: ")
            
            if opcao == '1':
                self.menu_agendamentos()
            elif opcao == '2':
                self.menu_monte_prato()
            elif opcao == '3':
                self.monitoramento.menu_monitoramento()
            elif opcao == '4':
                break
            else:
                print("OpÃ§Ã£o invÃ¡ida")
